# simulation_lqr_animation.py (새 이름으로 저장 권장)
import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp
import control as ct
import matplotlib.animation as animation # <--- 애니메이션 모듈 추가

# --- 0. 한글 폰트 설정 (Windows 기준) ---
try:
    plt.rcParams['font.family'] = 'Malgun Gothic'
    plt.rcParams['axes.unicode_minus'] = False
except:
    print("한글 폰트(맑은 고딕) 설정에 실패했습니다.")

# --- 1. LQR 제어기 클래스 (수정 없음) ---
class LQRControllerPython:
    def __init__(self, A, B, Q, R, desired_state):
        self.A, self.B, self.Q, self.R = A, B, Q, R
        self.desired_state = np.asarray(desired_state)
        self.K = self.compute_lqr_gain()

    def compute_lqr_gain(self):
        try:
            K, P, E = ct.lqr(self.A, self.B, self.Q, self.R)
            print("--- LQR 게인 K 계산 성공 ---")
            print(K)
            return K
        except Exception as e:
            print(f"LQR 계산 오류: {e}")
            return None

    def get_output(self, current_state):
        if self.K is None: return 0.0
        state_error = np.asarray(current_state) - self.desired_state
        u = -self.K.dot(state_error)
        return u.item()

# --- 2. 동역학 모델 (LQR 피드백 적용) (수정 없음) ---
def pendulum_dynamics_lqr(t, y, M, m, L, g, b_cart, b_pendulum, controller):
    u = controller.get_output(y)
    x_dot, theta, theta_dot = y[1], y[2], y[3]
    Sy, Cy = np.sin(theta), np.cos(theta)
    
    M_mat = np.array([[M + m, m * L * Cy], [m * L * Cy, m * L**2]])
    RHS = np.array([
        u - b_cart * x_dot + m * L * Sy * theta_dot**2,
        -m * g * L * Sy - b_pendulum * theta_dot
    ])
    
    try:
        accels = np.linalg.solve(M_mat, RHS)
        x_ddot, theta_ddot = accels[0], accels[1]
    except np.linalg.LinAlgError:
        x_ddot, theta_ddot = 0.0, 0.0
    
    return [y[1], x_ddot, y[3], theta_ddot]

# --- 3. 시뮬레이션 실행 ---
if __name__ == '__main__':
    # 3-1. 물리 파라미터 설정
    M, m, L, g = 100.0, 5.0, 25.0, 9.81
    b_cart, b_pendulum = 1.0, 0.5 # 고객님 설정값

    # 3-2. LQR을 위한 선형화(Linearization) 모델 정의
    A = np.array([
        [0, 1, 0, 0],
        [0, -b_cart/M, (m*g)/M, 0],
        [0, 0, 0, 1],
        [0, b_cart/(M*L), -(M+m)*g/(M*L), -b_pendulum/(M*L)]
    ])
    B = np.array([[0], [1/M], [0], [-1/(M*L)]])

    # 3-3. LQR 비용 행렬 (★★성능 튜닝된 값★★)
    Q = np.diag([100.0, 1.0, 5000.0, 100.0]) 
    R = np.array([[0.1]]) 

    # 3-4. 제어기 생성
    desired_state = np.array([5.0, 0.0, 0.0, 0.0]) 
    controller = LQRControllerPython(A, B, Q, R, desired_state)

    # 3-5. 시뮬레이션 설정 (애니메이션을 위해 60초로 설정)
    t_total = 60.0 
    t_span = [0, t_total]
    initial_angle_deg = 60.0
    initial_angle_rad = np.deg2rad(initial_angle_deg)
    initial_state = [0.0, 0.0, initial_angle_rad, 0.0] 

    # --- 시뮬레이션 실행 ---
    sol = solve_ivp(
        pendulum_dynamics_lqr, t_span, initial_state, 
        args=(M, m, L, g, b_cart, b_pendulum, controller), 
        dense_output=True, rtol=1e-6, atol=1e-9
    )

    # --- 4. (신규) 애니메이션을 위한 X,Y 좌표 리스트 계산 ---
    # 1000개의 프레임으로 데이터 생성
    frames = 1000
    t_plot = np.linspace(t_span[0], t_span[1], frames)
    y_plot = sol.sol(t_plot)
    
    # X,Y 좌표 리스트 계산
    cart_x_list = y_plot[0]
    pendulum_angle_list = y_plot[2]
    
    # 진자(추)의 X, Y 좌표 계산
    bob_x_list = cart_x_list + L * np.sin(pendulum_angle_list)
    bob_y_list = -L * np.cos(pendulum_angle_list) # 카트 Y좌표는 0으로 가정

    # --- 5. (신규) Matplotlib 애니메이션 생성 ---
    
    fig = plt.figure(figsize=(10, 8))
    # Y축은 진자 길이(25m)보다 길게, X축은 카트 이동(5m)보다 넓게 설정
    ax = plt.axes(xlim=(-10, 15), ylim=(-28, 5)) 
    ax.set_aspect('equal') # X, Y 축 비율을 1:1로
    ax.grid(True)
    ax.set_title('LQR Anti-Sway 애니메이션', fontsize=16)
    ax.set_xlabel('Position X (m)')
    ax.set_ylabel('Position Y (m)')

    # 애니메이션 '배우' 생성 (초기엔 비어있음)
    cart_width = 2.5 # 카트 너비
    cart_height = 1.0 # 카트 높이
    cart = plt.Rectangle((0, 0), cart_width, cart_height, fc='blue') # 사각형 카트
    ax.add_patch(cart)
    
    line, = ax.plot([], [], 'o-', lw=2, color='red', markersize=8) # 와이어(선)와 추(o)
    target_line = ax.axvline(desired_state[0], color='black', linestyle='--', label=f'목표 위치 ({desired_state[0]:.1f}m)')
    time_text = ax.text(0.02, 0.95, '', transform=ax.transAxes)

    # 애니메이션 초기화 함수
    def init():
        cart.set_xy((-cart_width/2, -cart_height/2))
        line.set_data([], [])
        time_text.set_text('')
        return line, cart, time_text,

    # 애니메이션 프레임 업데이트 함수
    def animate(i):
        # i번째 프레임의 X,Y 좌표 가져오기
        cx = cart_x_list[i]
        bx = bob_x_list[i]
        by = bob_y_list[i]
        
        # 카트 위치 업데이트
        cart.set_xy((cx - cart_width/2, -cart_height/2))
        
        # 와이어/추 위치 업데이트 (피봇: [cx, 0], 추: [bx, by])
        line.set_data([cx, bx], [0, by])
        
        # 시간 텍스트 업데이트
        time_text.set_text(f'Time: {t_plot[i]:.1f}s')
        return line, cart, time_text,

    # 애니메이션 생성
    # interval = (t_total * 1000) / frames  (예: 60초 / 1000프레임 = 60ms)
    ani = animation.FuncAnimation(fig, animate, init_func=init,
                                  frames=frames, interval=(t_total*1000)/frames, 
                                  blit=True, repeat=False)
    
    plt.legend()
    plt.show()
